import pygame
import random
import sys
import json

# ØªÙ†Ø¸ÛŒÙ…Ø§Øª Ø§ÙˆÙ„ÛŒÙ‡
pygame.init()
WIDTH, HEIGHT = 600, 600
CELL_SIZE = WIDTH // 13
ROWS, COLS = 15, 15
FPS = 30

# Ø±Ù†Ú¯â€ŒÙ‡Ø§
COLORS = {
    "red": (255, 0, 0),
    "blue": (0, 0, 255),
    "green": (0, 255, 0),
    "yellow": (255, 255, 0),
    "light_red": (255, 200, 200),
    "light_blue": (200, 200, 255),
    "light_green": (200, 255, 200),
    "light_yellow": (255, 255, 200),
    "white": (255, 255, 255),
    "black": (0, 0, 0),
    "gray": (200, 200, 200),
}

# Ù…Ø³ÛŒØ± Ø­Ø±Ú©Øª Ù…Ù‡Ø±Ù‡â€ŒÙ‡Ø§
PATH_POSITIONS = [
    (2, 5), (3, 5), (4, 5), (5, 5),  
    (5, 4), (5, 3), (5, 2), (5, 1),  
    (6, 1), (7, 2), (7, 3), (7, 4), (7, 5),  
    (8, 5), (9, 5), (10, 5), (11, 5), (11, 6),  
    (10, 7), (9, 7), (8, 7), (7, 7), (7, 8),  
    (7, 9), (7, 10), (7, 11), (6, 11),  
    (5, 11), (5, 10), (5, 9), (5, 8), (5, 7),  
    (4, 7), (3, 7), (2, 7), (1, 7), (1, 6)  
]  



# Ù†Ù‚Ø§Ø· ÙˆØ±ÙˆØ¯ 
ENTRY_POINTS = {
    "blue": (7,1),
    "green": (5,11),
    "red": (1, 5),
    "yellow": (11,7)
}

PARKING_POSITIONS = {
    "red": [(1, 1), (1, 2), (2, 1), (2, 2)],
    "blue": [(11,1), (10,1), (11,2), (10,2)],
    "green": [(2,11), (2,10), (1,10), (1,11)],
    "yellow": [(10,11), (10,10), (11,10), (11,11)]
}

# Ù…Ú©Ø§Ù†â€ŒÙ‡Ø§ÛŒ ÙˆØ³Ø· ØµÙØ­Ù‡
CROSS_PATHS = {
    "blue": [(6,2), (6,3), (6,4), (6,5)],
    "red": [(3,6), (4,6), (5,6), (2,6)],
    "yellow": [(9,6), (7,6), (8,6), (10,6)],
    "green": [(6,7), (6,8), (6,9), (6,10)]
}

START_PATH_INDEX = {
    "red": 0,     # Ø§ÙˆÙ„ÛŒÙ† Ù†Ù‚Ø·Ù‡ Ø§Ø² Ù…Ø³ÛŒØ± Ø¨Ø±Ø§ÛŒ Ù‚Ø±Ù…Ø²
    "blue": 9,    # Ø§ÙˆÙ„ÛŒÙ† Ù†Ù‚Ø·Ù‡ Ø§Ø² Ù…Ø³ÛŒØ± Ø¨Ø±Ø§ÛŒ Ø¢Ø¨ÛŒ
    "green": 27,  # Ø§ÙˆÙ„ÛŒÙ† Ù†Ù‚Ø·Ù‡ Ø§Ø² Ù…Ø³ÛŒØ± Ø¨Ø±Ø§ÛŒ Ø³Ø¨Ø²
    "yellow": 18  # Ø§ÙˆÙ„ÛŒÙ† Ù†Ù‚Ø·Ù‡ Ø§Ø² Ù…Ø³ÛŒØ± Ø¨Ø±Ø§ÛŒ Ø²Ø±Ø¯
}

# Ú©Ù„Ø§Ø³ ØªÙ†Ø¸ÛŒÙ…Ø§Øª
class Settings:
    def __init__(self):
        self.data = {"players": 4, "sound": True}
        self.load()

    def load(self):
        try:
            with open("settings.json", "r") as f:
                self.data = json.load(f)
        except FileNotFoundError:
            self.save()

    def save(self):
        with open("settings.json", "w") as f:
            json.dump(self.data, f)
 
# Ú©Ù„Ø§Ø³ Ø¨Ø§Ø²ÛŒÚ©Ù†
class Player:
    def __init__(self, color):
        self.color = color
        self.pieces = [None] * 4  # None ÛŒØ¹Ù†ÛŒ Ù…Ù‡Ø±Ù‡ Ø¯Ø± Ø®Ø§Ù†Ù‡ Ù…Ø¨Ø¯Ø§ Ø§Ø³Øª
        self.entry_point = ENTRY_POINTS[color]
        self.active_pieces = 0
        

# Ú©Ù„Ø§Ø³ Ù…Ù†ÙˆÛŒ Ù¾ÙˆÛŒØ§
class Menu:
    def __init__(self, game):
        self.game = game
        self.options = ["New Game", "How To Play", "Exit"]
        self.selected = 0

    def draw_menu(self):
        self.game.screen.fill(COLORS["white"])
        for i, option in enumerate(self.options):
            color = COLORS["red"] if i == self.selected else COLORS["black"]
            text = pygame.font.SysFont("Arial", 40).render(option, True, color)
            self.game.screen.blit(text, (WIDTH//2 - 100, HEIGHT//2 - 50 + i*60))
        pygame.display.update()

    def handle_input(self):
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                pygame.quit()
                sys.exit()
            if event.type == pygame.KEYDOWN:
                if event.key == pygame.K_UP:
                    self.selected = (self.selected - 1) % len(self.options)
                elif event.key == pygame.K_DOWN:
                    self.selected = (self.selected + 1) % len(self.options)
                elif event.key == pygame.K_RETURN:
                    if self.selected == 0:
                        self.select_players()
                    elif self.selected == 1:
                        self.show_help()
                    elif self.selected == 2:
                        pygame.quit()
                        sys.exit()
    def select_players(self):
        selecting = True
        selected_option = 0  # Û° Ø¨Ø±Ø§ÛŒ Ø¯Ùˆ Ù†ÙØ±Ù‡ØŒ Û± Ø¨Ø±Ø§ÛŒ Ú†Ù‡Ø§Ø± Ù†ÙØ±Ù‡
        options = ["4 Players", "2 Players"]

        while selecting:
            self.game.screen.fill(COLORS["white"])
            font = pygame.font.SysFont("Arial", 40)
            
            for i, option in enumerate(options):
                color = COLORS["red"] if i == selected_option else COLORS["black"]
                text = font.render(option, True, color)
                self.game.screen.blit(text, (WIDTH//2 - 100, HEIGHT//2 - 50 + i*60))

            pygame.display.update()

            for event in pygame.event.get():
                if event.type == pygame.QUIT:
                    pygame.quit()
                    sys.exit()
                if event.type == pygame.KEYDOWN:
                    if event.key == pygame.K_UP or event.key == pygame.K_DOWN:
                        selected_option = 1 - selected_option  # Ø¨ÛŒÙ† Ø¯Ùˆ Ú¯Ø²ÛŒÙ†Ù‡ Ø¬Ø§Ø¨Ù‡â€ŒØ¬Ø§ Ø´ÙˆØ¯
                    elif event.key == pygame.K_RETURN:
                        self.game.settings.data["players"] = 4 if selected_option == 0 else 2
                        self.game.settings.save()
                        self.game.run_game()
                        selecting = False
    def show_help(self):
        showing = True
        help_text = [
            "ğŸ² Ludo Game Instructions ğŸ²",
            "1. Press SPACE to roll the dice.",
            "2. Use keys 1-4 to move your pieces.",
            "3. To start moving a piece, you must roll a 6.",
            "4. If you land on an opponent's piece,",
            "they go back to start.",
            "5. The goal is to get all your pieces to the finish area.",
            "Press ESC to go back."
        ]

        while showing:
            self.game.screen.fill(COLORS["white"])
            font = pygame.font.SysFont("Arial", 24)

            for i, line in enumerate(help_text):
                text = font.render(line, True, COLORS["black"])
                self.game.screen.blit(text, (WIDTH//2 - 200, 100 + i * 40))

            pygame.display.update()

            for event in pygame.event.get():
                if event.type == pygame.QUIT:
                    pygame.quit()
                    sys.exit()
                if event.type == pygame.KEYDOWN and event.key == pygame.K_ESCAPE:
                    showing = False
            

# Ú©Ù„Ø§Ø³ Ø§ØµÙ„ÛŒ Ø¨Ø§Ø²ÛŒ
class Game:
    def __init__(self):
        self.screen = pygame.display.set_mode((WIDTH, HEIGHT))
        pygame.display.set_caption("Ù…Ù†Ú†")
        self.menu = Menu(self)
        self.settings = Settings()
        self.clock = pygame.time.Clock()
        self.players = [Player("red"), Player("blue")]
        if self.settings.data["players"] == 4:
            self.players.extend([Player("green"), Player("yellow")])


        self.current_turn = 0
        self.dice_value = 1
        self.dice_rolled = False  # ÙˆØ¶Ø¹ÛŒØª Ù†Ø´Ø§Ù†â€ŒØ¯Ù‡Ù†Ø¯Ù‡ Ú†Ø±Ø®Ø§Ù†Ø¯Ù† ØªØ§Ø³
        self.consecutive_sixes = 0  # Ø´Ù…Ø§Ø±Ù†Ø¯Ù‡ Ø¨Ø±Ø§ÛŒ ØªØ¹Ø¯Ø§Ø¯ Ø¯ÙØ¹Ø§Øª Ù¾Ø´Øª Ø³Ø± Ù‡Ù… ØªØ§Ø³ 6 Ø¢ÙˆØ±Ø¯Ù†

    def draw_dice(self, dice_value):
        dice_size = 37 
        # ØªØ¹ÛŒÛŒÙ† Ù…ÙˆÙ‚Ø¹ÛŒØª ØªØ§Ø³ Ø¯Ø± Ù¾Ø§ÛŒÛŒÙ† ÙˆØ³Ø· ØµÙØ­Ù‡
        dice_x = (WIDTH - dice_size) // 2  
        dice_y = HEIGHT - dice_size - 10  # ÙØ§ØµÙ„Ù‡ 10 Ù¾ÛŒÚ©Ø³Ù„ Ø§Ø² Ù¾Ø§ÛŒÛŒÙ† ØµÙØ­Ù‡
        dot_radius = 5  # Ø´Ø¹Ø§Ø¹ Ù†Ù‚Ø·Ù‡â€ŒÙ‡Ø§
        offset = dice_size // 4  # ÙØ§ØµÙ„Ù‡ Ø¨Ø±Ø§ÛŒ Ù‚Ø±Ø§Ø±Ú¯ÛŒØ±ÛŒ Ù†Ù‚Ø§Ø·

        # Ø±Ø³Ù… Ù¾Ø³â€ŒØ²Ù…ÛŒÙ†Ù‡ ØªØ§Ø³
        pygame.draw.rect(self.screen, COLORS["white"], (dice_x, dice_y, dice_size, dice_size))
        pygame.draw.rect(self.screen, COLORS["black"], (dice_x, dice_y, dice_size, dice_size), 2)

        # ØªØ¹ÛŒÛŒÙ† Ù…ÙˆÙ‚Ø¹ÛŒØªâ€ŒÙ‡Ø§ÛŒ Ù†Ù‚Ø·Ù‡â€ŒÙ‡Ø§
        positions = {
            "top_left": (dice_x + offset, dice_y + offset),
            "top_right": (dice_x + dice_size - offset, dice_y + offset),
            "middle": (dice_x + dice_size // 2, dice_y + dice_size // 2),
            "bottom_left": (dice_x + offset, dice_y + dice_size - offset),
            "bottom_right": (dice_x + dice_size - offset, dice_y + dice_size - offset),
            "middle_left": (dice_x + offset, dice_y + dice_size // 2),
            "middle_right": (dice_x + dice_size - offset, dice_y + dice_size // 2),
        }

        # Ø±Ø³Ù… Ù†Ù‚Ø·Ù‡â€ŒÙ‡Ø§ Ø¨Ø± Ø§Ø³Ø§Ø³ Ù…Ù‚Ø¯Ø§Ø± ØªØ§Ø³
        if dice_value == 1:
            pygame.draw.circle(self.screen, COLORS["black"], positions["middle"], dot_radius)
        elif dice_value == 2:
            pygame.draw.circle(self.screen, COLORS["black"], positions["top_left"], dot_radius)
            pygame.draw.circle(self.screen, COLORS["black"], positions["bottom_right"], dot_radius)
        elif dice_value == 3:
            pygame.draw.circle(self.screen, COLORS["black"], positions["top_left"], dot_radius)
            pygame.draw.circle(self.screen, COLORS["black"], positions["middle"], dot_radius)
            pygame.draw.circle(self.screen, COLORS["black"], positions["bottom_right"], dot_radius)
        elif dice_value == 4:
            pygame.draw.circle(self.screen, COLORS["black"], positions["top_left"], dot_radius)
            pygame.draw.circle(self.screen, COLORS["black"], positions["top_right"], dot_radius)
            pygame.draw.circle(self.screen, COLORS["black"], positions["bottom_left"], dot_radius)
            pygame.draw.circle(self.screen, COLORS["black"], positions["bottom_right"], dot_radius)
        elif dice_value == 5:
            pygame.draw.circle(self.screen, COLORS["black"], positions["top_left"], dot_radius)
            pygame.draw.circle(self.screen, COLORS["black"], positions["top_right"], dot_radius)
            pygame.draw.circle(self.screen, COLORS["black"], positions["middle"], dot_radius)
            pygame.draw.circle(self.screen, COLORS["black"], positions["bottom_left"], dot_radius)
            pygame.draw.circle(self.screen, COLORS["black"], positions["bottom_right"], dot_radius)
        elif dice_value == 6:
            pygame.draw.circle(self.screen, COLORS["black"], positions["top_left"], dot_radius)
            pygame.draw.circle(self.screen, COLORS["black"], positions["top_right"], dot_radius)
            pygame.draw.circle(self.screen, COLORS["black"], positions["middle_left"], dot_radius)
            pygame.draw.circle(self.screen, COLORS["black"], positions["middle_right"], dot_radius)
            pygame.draw.circle(self.screen, COLORS["black"], positions["bottom_left"], dot_radius)
            pygame.draw.circle(self.screen, COLORS["black"], positions["bottom_right"], dot_radius)
    

    def draw_board(self):
        self.screen.fill(COLORS["white"])
        # Ø±Ø³Ù… ØµÙ„ÛŒØ¨ Ø¯Ø± ÙˆØ³Ø· ØµÙØ­Ù‡
          # Ø±Ù†Ú¯â€ŒØ¢Ù…ÛŒØ²ÛŒ Ù…Ø­Ø¯ÙˆØ¯Ù‡ ØµÙ„ÛŒØ¨ Ø¨Ø±Ø§ÛŒ Ù‡Ø± Ø±Ù†Ú¯
        cross_colors = {
        
            "blue": (200, 200, 255),
            "red": (255, 200, 200),   
            "green": (200, 255, 200),  
            "yellow": (255, 255, 200)  # Ø²Ø±Ø¯ Ú©Ù…Ø±Ù†Ú¯
        }

        for color, positions in CROSS_PATHS.items():
            for x,y in positions:
                pygame.draw.rect(self.screen, cross_colors[color],pygame.Rect(x * CELL_SIZE, y * CELL_SIZE, CELL_SIZE,CELL_SIZE))
                pygame.draw.rect(self.screen, COLORS["gray"], (x * CELL_SIZE, y * CELL_SIZE, CELL_SIZE, CELL_SIZE), 1)



        # Ø±Ø³Ù… Ù…Ø³ÛŒØ± Ø§ØµÙ„ÛŒ
        for pos in PATH_POSITIONS:
            x, y = pos
            pygame.draw.rect(self.screen, COLORS["gray"], (x * CELL_SIZE, y * CELL_SIZE, CELL_SIZE, CELL_SIZE), 1)

        # Ø±Ø³Ù… Ø®Ø§Ù†Ù‡â€ŒÙ‡Ø§ÛŒ Ù…Ø¨Ø¯Ø§
        for color, (x, y) in ENTRY_POINTS.items():
            pygame.draw.rect(self.screen, COLORS[f"light_{color}"], (x * CELL_SIZE, y * CELL_SIZE, CELL_SIZE, CELL_SIZE))

        # Ø±Ø³Ù… Ø®Ø§Ù†Ù‡â€ŒÙ‡Ø§ÛŒ Ù…Ù‚ØµØ¯
        for color, positions in PARKING_POSITIONS.items():
            for pos in positions:
                x, y = pos
                pygame.draw.rect(self.screen, COLORS[f"light_{color}"], (x * CELL_SIZE, y * CELL_SIZE, CELL_SIZE, CELL_SIZE))

        # Ø±Ø³Ù… Ù…Ù‡Ø±Ù‡â€ŒÙ‡Ø§ Ùˆ Ù†Ù…Ø§ÛŒØ´ Ø´Ù…Ø§Ø±Ù‡â€ŒÛŒ Ø¢Ù†â€ŒÙ‡Ø§
        font = pygame.font.SysFont("Arial", 18, bold=True)  # ÙÙˆÙ†Øª Ø¨Ø±Ø§ÛŒ Ø´Ù…Ø§Ø±Ù‡â€ŒÛŒ Ù…Ù‡Ø±Ù‡â€ŒÙ‡Ø§
        for player in self.players:
            for i in range(4):
                if player.pieces[i] is None:
                    parking_pos = PARKING_POSITIONS[player.color][i]
                    x, y = parking_pos
                else:
                    x, y = player.pieces[i]

                # Ø±Ø³Ù… Ù…Ù‡Ø±Ù‡ (Ø¯Ø§ÛŒØ±Ù‡)
                pygame.draw.circle(
                    self.screen,
                    COLORS[player.color],
                    (x * CELL_SIZE + CELL_SIZE // 2, y * CELL_SIZE + CELL_SIZE // 2),
                    CELL_SIZE // 3
                )

                # Ù†Ù…Ø§ÛŒØ´ Ø´Ù…Ø§Ø±Ù‡â€ŒÛŒ Ù…Ù‡Ø±Ù‡ Ø±ÙˆÛŒ Ø¯Ø§ÛŒØ±Ù‡
                text = font.render(str(i + 1), True, COLORS["black"])  # Ø´Ù…Ø§Ø±Ù‡ Ù…Ù‡Ø±Ù‡ (1 ØªØ§ 4)
                self.screen.blit(text, (x * CELL_SIZE + CELL_SIZE // 2 - 5, y * CELL_SIZE + CELL_SIZE // 2 - 10))

        #  Ù†Ù…Ø§ÛŒØ´ ØªÛŒÙ…ÛŒ Ú©Ù‡ Ù†ÙˆØ¨Øª Ø§ÙˆØ³Øª Ø¯Ø± Ø¨Ø§Ù„Ø§ÛŒ ÙˆØ³Ø· ØµÙØ­Ù‡**
        current_player = self.players[self.current_turn]
        font = pygame.font.SysFont("Arial", 24, bold=True)  # ÙÙˆÙ†Øª Ø¨Ø²Ø±Ú¯â€ŒØªØ± Ø¨Ø±Ø§ÛŒ Ù†Ù…Ø§ÛŒØ´ Ù†ÙˆØ¨Øª Ø¨Ø§Ø²ÛŒÚ©Ù†
        text = font.render(f"NOBAT: {current_player.color.upper()}", True, COLORS[current_player.color])
        
        text_rect = text.get_rect(center=(WIDTH // 2, 30))  # ØªÙ†Ø¸ÛŒÙ… Ù…ØªÙ† Ø¯Ø± Ù…Ø±Ú©Ø² Ø¨Ø§Ù„Ø§
        self.screen.blit(text, text_rect)

        # Ø±Ø³Ù… ØªØ§Ø³
        self.draw_dice(self.dice_value)

        pygame.display.update()
    SKIP_POSITIONS = set(ENTRY_POINTS.values())
    def move_piece(self, player, piece_index, dice):
        current_pos = player.pieces[piece_index]
        
        
        if player.pieces[piece_index] is None:
            if dice == 6:
                entry_position = ENTRY_POINTS[player.color]
                player.pieces[piece_index] = entry_position  # Ù…Ù‡Ø±Ù‡ ÙˆØ§Ø±Ø¯ Ø®Ø§Ù†Ù‡ ÙˆØ±ÙˆØ¯ÛŒ Ø´Ø¯
                player.active_pieces += 1
                print(f" Ù…Ù‡Ø±Ù‡ {piece_index+1} Ø¨Ø§Ø²ÛŒÚ©Ù† {player.color} ÙˆØ§Ø±Ø¯ Ø®Ø§Ù†Ù‡ ÙˆØ±ÙˆØ¯ÛŒ Ø´Ø¯: {entry_position}")

    
            return

        # Ø§Ú¯Ø± Ù…Ù‡Ø±Ù‡ Ø¯Ø± Ø®Ø§Ù†Ù‡ ÙˆØ±ÙˆØ¯ÛŒ Ø§Ø³Øª Ùˆ Ø¨Ø§ÛŒØ¯ ÙˆØ§Ø±Ø¯ Ù…Ø³ÛŒØ± Ø§ØµÙ„ÛŒ Ø´ÙˆØ¯
        if current_pos == ENTRY_POINTS[player.color]:
            start_index = START_PATH_INDEX[player.color]
            new_index = start_index + (dice - 1)
            if new_index >= len(PATH_POSITIONS): 
                new_index = len(PATH_POSITIONS) - 1
            player.pieces[piece_index] = PATH_POSITIONS[new_index]
            print(f"ğŸš€ Ù…Ù‡Ø±Ù‡ {piece_index+1} ÙˆØ§Ø±Ø¯ Ù…Ø³ÛŒØ± Ø´Ø¯: {PATH_POSITIONS[new_index]}")
            return

        # Ø§Ú¯Ø± Ù…Ù‡Ø±Ù‡ Ø¯Ø± Ù…Ø³ÛŒØ± Ø§ØµÙ„ÛŒ Ù‚Ø±Ø§Ø± Ø¯Ø§Ø±Ø¯
        if current_pos in PATH_POSITIONS:
            idx = PATH_POSITIONS.index(current_pos)
            new_idx = idx + dice 
            # Ø§Ú¯Ø± Ù…Ù‡Ø±Ù‡ Ø¨Ù‡ ÙˆØ±ÙˆØ¯ÛŒ ØµÙ„ÛŒØ¨ Ø±Ø³ÛŒØ¯
            if new_idx >= len(PATH_POSITIONS):  
                player.pieces[piece_index] = CROSS_PATHS[player.color][0]  # ÙˆØ±ÙˆØ¯ Ø¨Ù‡ ØµÙ„ÛŒØ¨
                print(f"âœ… Ù…Ù‡Ø±Ù‡ {piece_index+1} Ø§Ø² {player.color} ÙˆØ§Ø±Ø¯ ØµÙ„ÛŒØ¨ Ø´Ø¯!")
                return
            player.pieces[piece_index] = PATH_POSITIONS[new_idx]
            print(f"ğŸš€ Ù…Ù‡Ø±Ù‡ {piece_index+1} Ø¨Ù‡ Ø®Ø§Ù†Ù‡ {player.pieces[piece_index]} Ø­Ø±Ú©Øª Ú©Ø±Ø¯.")
            return


            # Ø§Ú¯Ø± Ù…Ù‡Ø±Ù‡ Ø¨Ù‡ Ø§Ù†ØªÙ‡Ø§ÛŒ Ù…Ø³ÛŒØ± Ø§ØµÙ„ÛŒ Ø±Ø³ÛŒØ¯ØŒ ÙˆØ§Ø±Ø¯ ØµÙ„ÛŒØ¨ Ø´ÙˆØ¯
        if current_pos in ENTRY_POINTS.values() and player.color in CROSS_PATHS:
                color = player.color  # Ø±Ù†Ú¯ Ø¨Ø§Ø²ÛŒÚ©Ù† ÙØ¹Ù„ÛŒ
                if current_pos == ENTRY_POINTS[color]-1:  # Ø§Ú¯Ø± Ù…Ù‡Ø±Ù‡ Ø¨Ù‡ ÙˆØ±ÙˆØ¯ÛŒ ØµÙ„ÛŒØ¨ Ø®ÙˆØ¯Ø´ Ø±Ø³ÛŒØ¯
                    print(f"âœ… Ù…Ù‡Ø±Ù‡ {piece_index+1} Ø§Ø² {color} ÙˆØ§Ø±Ø¯ ØµÙ„ÛŒØ¨ Ø´Ø¯!")
                    player.pieces[piece_index] = CROSS_PATHS[color][0]  # Ø§ÙˆÙ„ÛŒÙ† Ø®Ø§Ù†Ù‡ ØµÙ„ÛŒØ¨
                    return
            # Ø­Ø±Ú©Øª Ø¹Ø§Ø¯ÛŒ Ø¯Ø± Ù…Ø³ÛŒØ± Ø§ØµÙ„ÛŒ
                player.pieces[piece_index] = PATH_POSITIONS[new_idx]
                return

        if current_pos in CROSS_PATHS[player.color]:
            idx = CROSS_PATHS[player.color].index(current_pos)
            if idx == len(CROSS_PATHS[player.color]) - 1:  # Ø§Ú¯Ø± Ù…Ù‡Ø±Ù‡ Ø¯Ø± Ø¢Ø®Ø± ØµÙ„ÛŒØ¨ Ø§Ø³Øª
                player.pieces[piece_index] = PARKING_POSITIONS[player.color][0]  # ÙˆØ±ÙˆØ¯ Ø¨Ù‡ Ù¾Ø§Ø±Ú©ÛŒÙ†Ú¯
                print(f"ğŸ‰ Ù…Ù‡Ø±Ù‡ {piece_index+1} ÙˆØ§Ø±Ø¯ Ù¾Ø§Ø±Ú©ÛŒÙ†Ú¯ Ø´Ø¯: {player.pieces[piece_index]}")
                return

        if current_pos in PARKING_POSITIONS[player.color]:
            idx = PARKING_POSITIONS[player.color].index(current_pos)
            new_idx = min(idx + dice, len(PARKING_POSITIONS[player.color]) - 1)  
            player.pieces[piece_index] = PARKING_POSITIONS[player.color][new_idx]
            print(f"ğŸ¡ Ù…Ù‡Ø±Ù‡ {piece_index+1} Ø¯Ø± Ù¾Ø§Ø±Ú©ÛŒÙ†Ú¯ Ø­Ø±Ú©Øª Ú©Ø±Ø¯: {player.pieces[piece_index]}")
            return


        # Ø§Ú¯Ø± Ù…Ù‡Ø±Ù‡ Ø¯Ø± ØµÙ„ÛŒØ¨ Ø§Ø³ØªØŒ Ø¨Ø§ÛŒØ¯ Ø­Ø±Ú©Øª Ú©Ù†Ø¯
        if current_pos in CROSS_PATHS[player.color]:
            idx = CROSS_PATHS[player.color].index(current_pos)
            new_idx = idx + dice

            if new_idx >= len(CROSS_PATHS[player.color]):  # Ø§Ú¯Ø± Ù…Ù‡Ø±Ù‡ Ø¨Ù‡ Ø¢Ø®Ø±ÛŒÙ† Ø®Ø§Ù†Ù‡ ØµÙ„ÛŒØ¨ Ø±Ø³ÛŒØ¯ØŒ Ù…ØªÙˆÙ‚Ù Ø´ÙˆØ¯
                new_idx = len(CROSS_PATHS[player.color]) - 1

            player.pieces[piece_index] = CROSS_PATHS[player.color][new_idx]
            print(f"ğŸ”· Ù…Ù‡Ø±Ù‡ {piece_index+1} Ø¯Ø± ØµÙ„ÛŒØ¨ Ø­Ø±Ú©Øª Ú©Ø±Ø¯: {player.pieces[piece_index]}")
            return
          

        # Ø¨Ø±Ø±Ø³ÛŒ Ø¨Ø±Ø®ÙˆØ±Ø¯ Ù…Ù‡Ø±Ù‡â€ŒÙ‡Ø§ÛŒ Ø­Ø±ÛŒÙ
        new_pos = player.pieces[piece_index]  # Ù…ÙˆÙ‚Ø¹ÛŒØª Ø¬Ø¯ÛŒØ¯ Ù…Ù‡Ø±Ù‡

        SAFE_ZONES = [8, 21, 34, 47]  # Ù…Ø«Ø§Ù„: Ø®Ø§Ù†Ù‡â€ŒÙ‡Ø§ÛŒ Ø§Ù…Ù† Ú©Ù‡ Ù…Ù‡Ø±Ù‡â€ŒÙ‡Ø§ Ø¯Ø± Ø¢Ù†Ø¬Ø§ Ù‚Ø§Ø¨Ù„ Ø¶Ø±Ø¨Ù‡ Ù†ÛŒØ³ØªÙ†Ø¯
        for p in self.players:
            if p == player:  # Ø¨Ø±Ø±Ø³ÛŒ Ù†Ú©Ù†ÛŒÙ… Ú©Ù‡ Ù…Ù‡Ø±Ù‡ Ø®ÙˆØ¯Ø´ Ø±Ø§ Ø¨Ø²Ù†Ø¯
                continue 
            for i in range(4):
                if p.pieces[i] == new_pos:  # Ø¨Ø±Ø±Ø³ÛŒ Ø¨Ø±Ø®ÙˆØ±Ø¯
                    if new_pos in SAFE_ZONES:
                        print(f"ğŸ›¡ Ù…Ù‡Ø±Ù‡ {i+1} Ø¨Ø§Ø²ÛŒÚ©Ù† {p.color} Ø¯Ø± Ø®Ø§Ù†Ù‡ Ø§Ù…Ù† Ø§Ø³Øª Ùˆ Ù‚Ø§Ø¨Ù„ Ø²Ø¯Ù† Ù†ÛŒØ³Øª!")
                        continue  # Ù…Ù‡Ø±Ù‡ Ø¯Ø± Ø®Ø§Ù†Ù‡ Ø§Ù…Ù† Ø§Ø³ØªØŒ Ù†Ù…ÛŒâ€ŒØªÙˆØ§Ù† Ø¢Ù† Ø±Ø§ Ø²Ø¯
                    
                    if new_pos not in PARKING_POSITIONS[p.color]:  # Ø¨Ø±Ø±Ø³ÛŒ Ø®Ø§Ù†Ù‡ Ù¾Ø§Ø±Ú©ÛŒÙ†Ú¯
                        print(f"âš¡ Ù…Ù‡Ø±Ù‡ {i+1} Ø¨Ø§Ø²ÛŒÚ©Ù† {p.color} ØªÙˆØ³Ø· Ø¨Ø§Ø²ÛŒÚ©Ù† {player.color} Ø²Ø¯Ù‡ Ø´Ø¯!")
                        p.pieces[i] = None  # Ù…Ù‡Ø±Ù‡ Ø­Ø±ÛŒÙ Ø¨Ù‡ Ø®Ø§Ù†Ù‡ Ù…Ø¨Ø¯Ø§ Ø¨Ø§Ø² Ù…ÛŒâ€ŒÚ¯Ø±Ø¯Ø¯
                        print(f"ğŸ”„ Ù…Ù‡Ø±Ù‡ {i+1} Ø¨Ø§Ø²ÛŒÚ©Ù† {p.color} Ø¨Ù‡ Ø®Ø§Ù†Ù‡ Ù…Ø¨Ø¯Ø§ Ø¨Ø§Ø²Ú¯Ø´Øª!")


    def next_turn(self):
        """ ØªØºÛŒÛŒØ± Ù†ÙˆØ¨Øª Ø¨Ù‡ Ø¨Ø§Ø²ÛŒÚ©Ù† Ø¨Ø¹Ø¯ÛŒ """
        self.current_turn = (self.current_turn + 1) % len(self.players)
        self.dice_rolled = False  # Ø¨Ø¹Ø¯ Ø§Ø² ØªØºÛŒÛŒØ± Ù†ÙˆØ¨ØªØŒ ØªØ§Ø³ Ù‡Ù†ÙˆØ² Ú†Ø±Ø®ÛŒØ¯Ù‡ Ù†Ø´Ø¯Ù‡
        self.consecutive_sixes = 0  # Ø´Ù…Ø§Ø±Ù†Ø¯Ù‡ Ø±Ø§ Ø±ÛŒØ³Øª Ú©Ù†ÛŒØ¯

      
    def roll_dice_until_six(self):
        """ ØªØ§Ø³ Ø±Ø§ Ù…ÛŒâ€ŒÚ†Ø±Ø®Ø§Ù†Ø¯ ØªØ§ Ø²Ù…Ø§Ù†ÛŒ Ú©Ù‡ Ø¨Ø§Ø²ÛŒÚ©Ù† 6 Ø¨ÛŒØ§ÙˆØ±Ø¯ """
        while True:
            self.dice_value = random.randint(1, 6)
            self.dice_rolled = True  # ØªØ§Ø³ Ø§Ù†Ø¯Ø§Ø®ØªÙ‡ Ø´Ø¯
            print(f" Ø¨Ø§Ø²ÛŒÚ©Ù† {self.players[self.current_turn].color} Ù…Ù‚Ø¯Ø§Ø± {self.dice_value} Ø¢ÙˆØ±Ø¯.")

            if self.dice_value == 6:
                print(f" Ø¨Ø§Ø²ÛŒÚ©Ù† {self.players[self.current_turn].color} Ù…Ù‚Ø¯Ø§Ø± 6 Ø¢ÙˆØ±Ø¯ Ùˆ Ø¬Ø§ÛŒØ²Ù‡ Ú¯Ø±ÙØª!")
                break  # Ø§Ø² Ø­Ù„Ù‚Ù‡ Ø®Ø§Ø±Ø¬ Ø´ÙˆØŒ Ú†ÙˆÙ† 6 Ø¢ÙˆØ±Ø¯Ù‡ Ø§Ø³Øª
            else:
                print(f" Ø¨Ø§Ø²ÛŒÚ©Ù† {self.players[self.current_turn].color} Ø¨Ø§ÛŒØ¯ Ø¯ÙˆØ¨Ø§Ø±Ù‡ ØªØ§Ø³ Ø¨ÛŒÙ†Ø¯Ø§Ø²Ø¯.")
                # Ù…Ù†ØªØ¸Ø± ÙØ´Ø±Ø¯Ù† Ø¯ÙˆØ¨Ø§Ø±Ù‡â€ŒÛŒ Space Ù…ÛŒâ€ŒÙ…Ø§Ù†ÛŒÙ…
                self.wait_for_space()

        return self.dice_value
    def roll_dice(self):
            """ Ù…Ø¯ÛŒØ±ÛŒØª Ø§Ù†Ø¯Ø§Ø®ØªÙ† ØªØ§Ø³ØŒ Ø¨Ø§ Ø§Ù…Ú©Ø§Ù† Ø§Ù†Ø¯Ø§Ø®ØªÙ† Ù…Ø¬Ø¯Ø¯ Ø¯Ø± ØµÙˆØ±Øª Ø¢ÙˆØ±Ø¯Ù† 6 """
            self.dice_value = random.randint(1, 6)
            self.dice_rolled = True  # ØªØ§Ø³ Ø§Ù†Ø¯Ø§Ø®ØªÙ‡ Ø´Ø¯
            print(f"ğŸ² Ø¨Ø§Ø²ÛŒÚ©Ù† {self.players[self.current_turn].color} Ù…Ù‚Ø¯Ø§Ø± {self.dice_value} Ø¢ÙˆØ±Ø¯.")

            if self.dice_value == 6:
                self.dice_value =random.randint(1,6)
                self.consecutive_sixes += 1
                print(f"ğŸ‰ Ø¨Ø§Ø²ÛŒÚ©Ù† {self.players[self.current_turn].color} Ù…Ù‚Ø¯Ø§Ø± 6 Ø¢ÙˆØ±Ø¯ Ùˆ Ø¬Ø§ÛŒØ²Ù‡ Ú¯Ø±ÙØª! ğŸ")
                if self.consecutive_sixes >= 3:  # Ø§Ú¯Ø± Ø³Ù‡ Ø¨Ø§Ø± Ù¾Ø´Øª Ø³Ø± Ù‡Ù… ØªØ§Ø³ 6 Ø¢ÙˆØ±Ø¯
                    print(f"ğŸš¨ Ø¨Ø§Ø²ÛŒÚ©Ù† {self.players[self.current_turn].color} Ø³Ù‡ Ø¨Ø§Ø± Ù¾Ø´Øª Ø³Ø± Ù‡Ù… ØªØ§Ø³ 6 Ø¢ÙˆØ±Ø¯! Ù†ÙˆØ¨Øª Ø¨Ù‡ Ø¨Ø§Ø²ÛŒÚ©Ù† Ø¨Ø¹Ø¯ÛŒ Ù…ÛŒâ€ŒØ±ÙˆØ¯.")
                    self.next_turn()
            else:
                self.next_turn()  # Ù†ÙˆØ¨Øª Ø¨Ù‡ Ø¨Ø§Ø²ÛŒÚ©Ù† Ø¨Ø¹Ø¯ÛŒ Ù…ÛŒâ€ŒØ±ÙˆØ¯
            return self.dice_value 
    def check_win(self):
            for player in self.players:
                parked = 0
                for pos in player.pieces:
                    if pos is not None and pos in CROSS_PATHS[player.color][-1]:
                        parked += 1
                if parked == 4:
                    return player
            return None
    def run_game(self):
        running = True
        while running:
            self.clock.tick(FPS)
            self.draw_board()
            current_player = self.players[self.current_turn]

            for event in pygame.event.get():
                if event.type == pygame.QUIT:
                    running = False
                    pygame.quit()
                    sys.exit()

                if event.type == pygame.KEYDOWN:
                    if event.key == pygame.K_SPACE and not self.dice_rolled:  # Ú†Ø±Ø®Ø§Ù†Ø¯Ù† ØªØ§Ø³ ÙÙ‚Ø· Ø¨Ø§ Ø§Ø³Ù¾ÛŒØ³
                        self.dice_value = self.roll_dice()
                        print(f"Ø¨Ø§Ø²ÛŒÚ©Ù† {current_player.color} ØªØ§Ø³ Ø§Ù†Ø¯Ø§Ø®Øª: {self.dice_value}")
                        self.dice_rolled = True  # Ù†Ø´Ø§Ù†â€ŒØ¯Ù‡Ù†Ø¯Ù‡ Ø§ÛŒÙ† Ú©Ù‡ ØªØ§Ø³ Ú†Ø±Ø®Ø§Ù†Ø¯Ù‡ Ø´Ø¯Ù‡

                        # Ø¨Ø±Ø±Ø³ÛŒ Ø§Ú¯Ø± Ù‡ÛŒÚ† Ù…Ù‡Ø±Ù‡â€ŒØ§ÛŒ Ù‚Ø§Ø¨Ù„ Ø­Ø±Ú©Øª Ù†Ø¨ÙˆØ¯ØŒ ØªØ§Ø³ Ø¯ÙˆØ¨Ø§Ø±Ù‡ Ú†Ø±Ø®Ø§Ù†Ø¯Ù‡ Ø´ÙˆØ¯
                        movable_pieces = [i for i in range(4) if self.can_move_piece(current_player, i, self.dice_value)]
                        if not movable_pieces:
                            print(f"â›” Ù‡ÛŒÚ† Ù…Ù‡Ø±Ù‡â€ŒØ§ÛŒ Ø§Ø² {current_player.color} Ù†Ù…ÛŒâ€ŒØªÙˆØ§Ù†Ø¯ Ø­Ø±Ú©Øª Ú©Ù†Ø¯! Ø¯ÙˆØ¨Ø§Ø±Ù‡ ØªØ§Ø³ Ø¨Ø²Ù†ÛŒØ¯.")
                            self.dice_rolled = False  # Ø§Ø¬Ø§Ø²Ù‡ Ú†Ø±Ø®Ø§Ù†Ø¯Ù† Ù…Ø¬Ø¯Ø¯ ØªØ§Ø³
                            continue  # Ù…Ù†ØªØ¸Ø± ÙØ´Ø±Ø¯Ù† Ø¯ÙˆØ¨Ø§Ø±Ù‡â€ŒÛŒ SPACE Ù…ÛŒâ€ŒÙ…Ø§Ù†ÛŒÙ…

                    if self.dice_rolled and event.key in [pygame.K_1, pygame.K_2, pygame.K_3, pygame.K_4]:
                        piece_index = event.key - pygame.K_1  # Ù…Ø­Ø§Ø³Ø¨Ù‡ Ø§ÛŒÙ†Ø¯Ú©Ø³ Ù…Ù‡Ø±Ù‡
                        if piece_index in movable_pieces:
                            self.move_piece(current_player, piece_index, self.dice_value)
                            self.draw_board()

                            winner = self.check_win()
                            if winner:
                                print(f"ğŸ† Ø¨Ø§Ø²ÛŒÚ©Ù† {winner.color} Ø¨Ø±Ù†Ø¯Ù‡ Ø´Ø¯!")
                                running = False

                            # Ø§Ú¯Ø± 6 Ù†ÛŒØ§Ù…Ø¯Ù‡ Ø¨Ø§Ø´Ø¯ØŒ Ù†ÙˆØ¨Øª ØªØºÛŒÛŒØ± Ú©Ù†Ø¯
                            if self.dice_value != 6 or not any(p is not None for p in current_player.pieces):
                                self.current_turn = (self.current_turn + 1) % len(self.players)
                            self.dice_rolled = False



                    pygame.display.update()

    def can_move_piece(self, player, piece_index, dice):
        """ Ø¨Ø±Ø±Ø³ÛŒ Ù…ÛŒâ€ŒÚ©Ù†Ø¯ Ú©Ù‡ Ø¢ÛŒØ§ ÛŒÚ© Ù…Ù‡Ø±Ù‡ Ù…ÛŒâ€ŒØªÙˆØ§Ù†Ø¯ Ø­Ø±Ú©Øª Ú©Ù†Ø¯ ÛŒØ§ Ù†Ù‡ """
        if player.pieces[piece_index] is None:
            return dice == 6  # ÙÙ‚Ø· Ø¨Ø§ 6 Ù…ÛŒâ€ŒØªÙˆØ§Ù†Ø¯ ÙˆØ§Ø±Ø¯ Ø´ÙˆØ¯

        current_pos = player.pieces[piece_index]

        # Ø§Ú¯Ø± Ù…Ù‡Ø±Ù‡ Ø¯Ø± Ø®Ø§Ù†Ù‡ ÙˆØ±ÙˆØ¯ÛŒ Ø§Ø³ØªØŒ Ø¨Ø±Ø±Ø³ÛŒ Ú©Ù†ÛŒÙ… Ú©Ù‡ Ø¢ÛŒØ§ Ù…ÛŒâ€ŒØªÙˆØ§Ù†Ø¯ ÙˆØ§Ø±Ø¯ Ù…Ø³ÛŒØ± Ø´ÙˆØ¯
        if current_pos == ENTRY_POINTS[player.color]:
            start_index = START_PATH_INDEX[player.color]
            new_index = start_index + (dice - 1)
            return new_index < len(PATH_POSITIONS)  # Ø¨Ø±Ø±Ø³ÛŒ Ø§ÛŒÙ†Ú©Ù‡ Ø¢ÛŒØ§ Ø¯Ø± Ù…Ø­Ø¯ÙˆØ¯Ù‡ Ù…Ø³ÛŒØ± Ù‡Ø³Øª ÛŒØ§ Ù†Ù‡

        # Ø¨Ø±Ø±Ø³ÛŒ Ù…Ø³ÛŒØ± Ø¹Ø§Ø¯ÛŒ
        if current_pos in PATH_POSITIONS:
            idx = PATH_POSITIONS.index(current_pos)
            new_idx = idx + dice
            return new_idx < len(PATH_POSITIONS)  # Ø§Ú¯Ø± Ø­Ø±Ú©Øª Ù…Ø¹ØªØ¨Ø± Ø¨Ø§Ø´Ø¯

        # Ø¨Ø±Ø±Ø³ÛŒ Ø®Ø§Ù†Ù‡â€ŒÙ‡Ø§ÛŒ Ù…Ù‚ØµØ¯ (Ù¾Ø§Ø±Ú©ÛŒÙ†Ú¯)
        if current_pos in PARKING_POSITIONS[player.color]:
            idx = PARKING_POSITIONS[player.color].index(current_pos)
            new_idx = idx + dice
            return new_idx < len(PARKING_POSITIONS[player.color])  # Ù…Ù‡Ø±Ù‡ Ø¯Ø± Ù…Ø­Ø¯ÙˆØ¯Ù‡ Ù¾Ø§Ø±Ú©ÛŒÙ†Ú¯ Ø­Ø±Ú©Øª Ú©Ù†Ø¯

        return False


    def run(self):
        while True:
            self.menu.draw_menu()
            self.menu.handle_input()

if __name__ == "__main__":
    game = Game()
    game.run()
